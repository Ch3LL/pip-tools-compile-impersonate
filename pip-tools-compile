#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
    pip-tools-compile
    ~~~~~~~~~~~~~~~~~

    Wrapper around pip-tools to "impersonate" different distributions when compiling requirements
'''

# Import Python Libs
from __future__ import absolute_import, print_function
import os
import sys
import atexit
import shutil
import logging
import argparse
import platform
import tempfile
import traceback
try:
    from unittest import mock
except ImportError:
    import mock

CAPTURE_OUTPUT = os.environ.get('CAPTURE_OUTPUT', '1') == '1'

if False:
    logging.basicConfig(level=logging.DEBUG, stream=sys.stderr)

# Import 3rd-party Libs
import six

# Import pip-tools Libs
import piptools.locations
PIP_TOOLS_CACHE_DIR = tempfile.mkdtemp(prefix='pip-tools-compile-cache-')
# Make sure we cleanup after ourselves
atexit.register(shutil.rmtree, PIP_TOOLS_CACHE_DIR, ignore_errors=True)
# Switch to our temp cache dir
piptools.locations.CACHE_DIR = PIP_TOOLS_CACHE_DIR
import piptools.scripts.compile

# Let's import get_supported because we need the returned value from the un-mocked function
from pip._internal.pep425tags import get_supported


log = logging.getLogger(__name__)


class ImpersonateSystem(object):

    __slots__ = ('_python_version_info')

    def __init__(self, python_version_info=None):
        if python_version_info:
            parts = [int(part) for part in python_version_info.split('.') if part.isdigit()]
            python_version_info = list(sys.version_info)
            for idx, part in enumerate(parts):
                python_version_info[idx] = part
            python_version_info = tuple(python_version_info)
        self._python_version_info = python_version_info

    def get_mocks(self):
        if self._python_version_info:
            yield mock.patch('pip._internal.pep425tags.get_impl_version_info',
                             return_value=self._python_version_info[:2])
        raise StopIteration

    def __enter__(self):
        for mock_obj in self.get_mocks():
            mock_obj.start()
        return self

    def __exit__(self, *args):
        mock.patch.stopall()


def get_supported_with_fixed_unicode_width(*args, **kwargs):
    supported = get_supported(*args, **kwargs)
    for version, abi, arch in supported[:]:
        if abi.endswith('u'):
            supported.append((version, abi[:-1], arch))
    return supported


class ImpersonateWindows(ImpersonateSystem):

    def get_mocks(self):
        for entry in super(ImpersonateWindows, self).get_mocks():
            yield entry
        # We don't want pip trying query python's internals, it knows how to mock that internal information
        yield mock.patch('pip._internal.pep425tags.get_config_var', return_value=None)
        # Impersonate Windows 32
        yield mock.patch('pip._internal.pep425tags.get_platform', return_value='win32')
        # Wrap get_supported in out own function call to fix unicode width issues
        yield mock.patch('pip._internal.pep425tags.get_supported', wraps=get_supported_with_fixed_unicode_width)
        yield mock.patch('pip._internal.index.get_supported', wraps=get_supported_with_fixed_unicode_width)
        # Patch pip's vendored packaging markers
        yield mock.patch('pip._vendor.packaging.markers.platform.machine', return_value='AMD64')
        yield mock.patch('pip._vendor.packaging.markers.platform.release', return_value='8.1')
        yield mock.patch('pip._vendor.packaging.markers.platform.system', return_value='Windows')
        yield mock.patch('pip._vendor.packaging.markers.platform.version', return_value='6.3.9600')


class ImpersonateDarwin(ImpersonateSystem):

    def get_mocks(self):
        for entry in super(ImpersonateDarwin, self).get_mocks():
            yield entry
        # We don't want pip trying query python's internals, it knows how to mock that internal information
        yield mock.patch('pip._internal.pep425tags.get_config_var', return_value=None)
        # Impersonate Windows 32
        yield mock.patch('pip._internal.pep425tags.get_platform', return_value='darwin')
        # Wrap get_supported in out own function call to fix unicode width issues
        yield mock.patch('pip._internal.pep425tags.get_supported', wraps=get_supported_with_fixed_unicode_width)
        yield mock.patch('pip._internal.index.get_supported', wraps=get_supported_with_fixed_unicode_width)
        # Patch pip's vendored packaging markers
        yield mock.patch('pip._vendor.packaging.markers.sys.platform', new_callable=mock.PropertyMock(return_value='darwin'))
        yield mock.patch('pip._vendor.packaging.markers.platform.machine', return_value='x86_64')
        yield mock.patch('pip._vendor.packaging.markers.platform.release', return_value='18.5.0')
        yield mock.patch('pip._vendor.packaging.markers.platform.system', return_value='Darwin')
        yield mock.patch('pip._vendor.packaging.markers.platform.version',
                         return_value='Darwin Kernel Version 18.5.0: Mon Mar 11 20:40:32 PDT 2019; root:xnu-4903.251.3~3/RELEASE_X86_64')
        yield mock.patch('pip._vendor.packaging.markers.platform.python_version', return_value='{}.{}.{}'.format(*self._python_version_info))


class ImpersonateLinux(ImpersonateSystem):

    def get_mocks(self):
        for entry in super(ImpersonateLinux, self).get_mocks():
            yield entry
        # We don't want pip trying query python's internals, it knows how to mock that internal information
        yield mock.patch('pip._internal.pep425tags.get_config_var', return_value=None)
        # Impersonate Windows 32
        yield mock.patch('pip._internal.pep425tags.get_platform', return_value='linux2')
        # Wrap get_supported in out own function call to fix unicode width issues
        yield mock.patch('pip._internal.pep425tags.get_supported', wraps=get_supported_with_fixed_unicode_width)
        yield mock.patch('pip._internal.index.get_supported', wraps=get_supported_with_fixed_unicode_width)
        # Patch pip's vendored packaging markers
        yield mock.patch('pip._vendor.packaging.markers.sys.platform', new_callable=mock.PropertyMock(return_value='linux2'))
        yield mock.patch('pip._vendor.packaging.markers.platform.machine', return_value='x86_64')
        yield mock.patch('pip._vendor.packaging.markers.platform.release', return_value='4.19.29-1-lts')
        yield mock.patch('pip._vendor.packaging.markers.platform.system', return_value='Linux')
        yield mock.patch('pip._vendor.packaging.markers.platform.version', return_value='#1 SMP Thu Mar 14 15:39:08 CET 2019')
        yield mock.patch('pip._vendor.packaging.markers.platform.python_version', return_value='{}.{}.{}'.format(*self._python_version_info))



class CatureSTDs(object):

    def __init__(self):
        self._stdout = six.StringIO()
        self._stderr = six.StringIO()
        self._sys_stdout = sys.stdout
        self._sys_stderr = sys.stderr

    def __enter__(self):
        sys.stdout = self._stdout
        sys.stderr = self._stderr
        return self

    def __exit__(self, *args):
        sys.stdout = self._sys_stdout
        sys.stderr = self._sys_stderr
        if not CAPTURE_OUTPUT:
            self._stdout.seek(0)
            sys.stdout.write(self._stdout.read())
            self._stderr.seek(0)
            sys.stderr.write(self._stderr.read())

    @property
    def stdout(self):
        self._stdout.seek(0)
        return self._stdout.read()

    @property
    def stderr(self):
        self._stdout.seek(0)
        return self._stdout.read()


def compile_requirement_file(fpath, options, unknown_args, failures, changes, retries=3):

    impersonations = {
        'darwin': ImpersonateDarwin,
        'windows': ImpersonateWindows,
        'linux': ImpersonateLinux
    }

    source_dir = os.path.dirname(fpath)
    dest_dir = os.path.join(source_dir, 'py{}'.format(options.py_version))
    if not os.path.isdir(dest_dir):
        os.makedirs(dest_dir)
    outfile = os.path.basename(fpath).replace('.in', '.txt')
    if options.out_prefix:
        outfile = '{}-{}'.format(options.out_prefix, outfile)
    outfile_path = os.path.join(dest_dir, outfile)
    try:
        with open(outfile_path) as rfh:
            previous_content = rfh.read()
    except (IOError, OSError):
        previous_content = ''
    call_args = ['pip-compile', '-o', outfile_path]
    if unknown_args:
        call_args += unknown_args
    if options.include:
        call_args += options.include
    call_args.append(fpath)

    original_sys_arg = sys.argv[:]
    retry = False
    try:
        with CatureSTDs() as capstds:
            print('Running: {}'.format(' '.join(call_args)))
            print('  Impersonating: {}'.format(options.platform))
            print('  Mocked Python Version: {}'.format(options.py_version))
            with impersonations[options.platform](options.py_version):
                sys.argv = call_args[:]
                try:
                    piptools.scripts.compile.cli()
                except SystemExit as exc:
                    if exc.code != 0:
                        if retries:
                            retry = True
                        else:
                            failures[fpath] = {
                                'stdout': capstds.stdout,
                                'stderr': capstds.stderr,
                                'exc': traceback.format_exc()
                            }
                            return
                    with open(outfile_path) as rfh:
                        if rfh.read() != previous_content:
                            changes[fpath] = {
                                'stdout': capstds.stdout,
                                'stderr': capstds.stderr,
                                'exc': None
                            }
                except Exception:
                    if retries:
                        retry = True
                    else:
                        failures[fpath] = {
                            'stdout': capstds.stdout,
                            'stderr': capstds.stderr,
                            'exc': traceback.format_exc()
                        }
    finally:
        sys.argv = original_sys_arg

    if retry is True:
        # Make sure there's no piptools cache, this will require downloading packages again
        # but at least it starts from scratch
        shutil.rmtree(PIP_TOOLS_CACHE_DIR)
        os.makedirs(PIP_TOOLS_CACHE_DIR)
        return compile_requirement_file(fpath,
                                        options,
                                        unknown_args,
                                        failures,
                                        changes,
                                        retries=retries-1)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--platform',
        choices=('windows', 'darwin', 'linux'),
        default=platform.system().lower()
    )
    parser.add_argument('--py-version', default='{}.{}'.format(*sys.version_info))
    parser.add_argument('--include', action='append', default=[])
    parser.add_argument('--out-prefix', default=None)
    parser.add_argument('files', nargs='+')

    options, unknown_args = parser.parse_known_args()

    changes = {}
    failures = {}
    for fpath in options.files:
        if not fpath.endswith('.in'):
            continue
        compile_requirement_file(fpath, options, unknown_args, failures, changes)

    if failures:
        for fpath, stds in failures.items():
            print('Failed to process {}'.format(fpath))
            if stds['exc']:
                print('Exception:')
                print(stds['exc'])
            if stds['stdout']:
                print('STDOUT:')
                print(stds['stdout'])
            if stds['stderr']:
                print('STDERR:')
                print(stds['stderr'])
        sys.exit(1)
    else:
        if changes:
            for fpath, stds in failures.items():
                print('{} contents changed...'.format(fpath))
        print('Done.')
        sys.exit(0)


if __name__ == '__main__':
    main()
