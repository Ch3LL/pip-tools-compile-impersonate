#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
    pip-tools-compile
    ~~~~~~~~~~~~~~~~~

    Wrapper around pip-tools to "impersonate" different distributions when compiling requirements
'''

# Import Python Libs
from __future__ import absolute_import, print_function
import os
import sys
import atexit
import shutil
import logging
import argparse
import platform
import tempfile
import functools
import traceback

if False:
    logging.basicConfig(level=logging.DEBUG, stream=sys.stderr)

# Import 3rd-party Libs
import six


class ImpersonateSystem(object):

    __slots__ = ('_store', '_python_version_info')

    def __init__(self, python_version_info=None):
        self._store = {}
        if python_version_info:
            parts = [int(part) for part in python_version_info.split('.') if part.isdigit()]
            python_version_info = list(sys.version_info)
            for idx, part in enumerate(parts):
                python_version_info[idx] = part
            python_version_info = tuple(python_version_info)
        self._python_version_info = python_version_info

    def get_patches(self):
        if self._python_version_info:
            return {(sys, 'version_info'): self._python_version_info}
        return {}

    def __enter__(self):
        for (obj, name), value in self.get_patches().items():
            patching_object = getattr(obj, name)
            self._store[(obj, name)] = patching_object

            if callable(patching_object):

                @functools.wraps(patching_object)
                def wrapper(*args, **kwargs):
                    if callable(value):
                        return value(*args, **kwargs)
                    return value

                setattr(obj, name, wrapper)
                del wrapper
            else:
                setattr(obj, name, value)
        return self

    def __exit__(self, *args):
        for (obj, key), value in self._store.items():
            setattr(obj, key, value)


def get_supported_with_fixed_unicode_width(*args, **kwargs):
    supported = get_supported_with_fixed_unicode_width.__original__(*args, **kwargs)
    for version, abi, arch in supported[:]:
        if abi.endswith('u'):
            supported.append((version, abi[:-1], arch))
    return supported


class ImpersonateWindows(ImpersonateSystem):

    def get_patches(self):
        # Late imports
        import pip._internal.index
        import pip._internal.pep425tags
        # Store a reference to the orifinal get_supported function
        try:
            get_supported_with_fixed_unicode_width.__original__
        except AttributeError:
            setattr(get_supported_with_fixed_unicode_width,
                    '__original__',
                    pip._internal.pep425tags.get_supported)
        patches = super(ImpersonateWindows, self).get_patches()
        patches.update({
            (os, 'name'): 'nt',
            (platform, 'machine'): 'AMD64',
            (platform, 'release'): '8.1',
            (platform, 'system'): 'Windows',
            (platform, 'version'): '6.3.9600',
            (sys, 'platform'): 'win32',
            (pip._internal.pep425tags, 'get_supported'): get_supported_with_fixed_unicode_width,
            (pip._internal.index, 'get_supported'): get_supported_with_fixed_unicode_width
        })
        return patches


class ImpersonatePassthrough(ImpersonateSystem):
    pass


class CatureSTDs(object):

    def __init__(self):
        self._stdout = six.StringIO()
        self._stderr = six.StringIO()
        self._sys_stdout = sys.stdout
        self._sys_stderr = sys.stderr

    def __enter__(self):
        sys.stdout = self._stdout
        sys.stderr = self._stderr
        return self

    def __exit__(self, *args):
        sys.stdout = self._sys_stdout
        sys.stderr = self._sys_stderr

    @property
    def stdout(self):
        self._stdout.seek(0)
        return self._stdout.read()

    @property
    def stderr(self):
        self._stdout.seek(0)
        return self._stdout.read()


def compile_requirement_file(fpath, options, unknown_args, failures, changes, retries=3):

    impersonations = {
        'windows': ImpersonateWindows,
        'linux': ImpersonatePassthrough
    }

    source_dir = os.path.dirname(fpath)
    dest_dir = os.path.join(source_dir, 'py{}'.format(sys.version_info.major))
    if not os.path.isdir(dest_dir):
        os.makedirs(dest_dir)
    outfile = os.path.basename(fpath).replace('.in', '.txt')
    if options.out_prefix:
        outfile = '{}-{}'.format(options.out_prefix, outfile)
    outfile_path = os.path.join(dest_dir, outfile)
    try:
        with open(outfile_path) as rfh:
            previous_content = rfh.read()
    except (IOError, OSError):
        previous_content = ''
    call_args = ['pip-compile', '-o', outfile_path]
    if unknown_args:
        call_args += unknown_args
    if options.include:
        call_args += options.include
    call_args.append(fpath)

    original_sys_arg = sys.argv[:]
    try:
        with CatureSTDs() as capstds:
            print('Running: {}'.format(' '.join(call_args)))
            with impersonations[options.platform](options.py_version):
                # Late import
                import pip._internal.index
                import piptools.scripts.compile
                sys.argv = call_args[:]
                try:
                    piptools.scripts.compile.cli()
                except SystemExit as exc:
                    if exc.code != 0:
                        failures[fpath] = {
                            'stdout': capstds.stdout,
                            'stderr': capstds.stderr,
                            'exc': traceback.format_exc()
                        }
                        return
                    with open(outfile_path) as rfh:
                        if rfh.read() != previous_content:
                            changes[fpath] = {
                                'stdout': capstds.stdout,
                                'stderr': capstds.stderr,
                                'exc': None
                            }
                except pip._internal.index.DistributionNotFound:
                    if retries:
                        return compile_requirement_file(
                            fpath,
                            options,
                            unknown_args,
                            failures,
                            changes,
                            retries=retries-1)

                    failures[fpath] = {
                        'stdout': capstds.stdout,
                        'stderr': capstds.stderr,
                        'exc': traceback.format_exc()
                    }
                except Exception:
                    failures[fpath] = {
                        'stdout': capstds.stdout,
                        'stderr': capstds.stderr,
                        'exc': traceback.format_exc()
                    }
    finally:
        sys.argv = original_sys_arg


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--platform',
        choices=('windows', 'darwin', 'linux'),
        default=platform.system().lower()
    )
    parser.add_argument('--py-version', default=None)
    parser.add_argument('--include', action='append', default=[])
    parser.add_argument('--out-prefix', default=None)
    parser.add_argument('files', nargs='+')

    options, unknown_args = parser.parse_known_args()

    # Tweak the pip-tools cache location. We always want a clean cache
    import piptools.locations
    PIP_TOOLS_CACHE_DIR = tempfile.mkdtemp(prefix='pip-tools-compile-cache-')
    # Switch to our temp cache dir
    piptools.locations.CACHE_DIR = PIP_TOOLS_CACHE_DIR
    # Make sure we cleanup after ourselves
    atexit.register(shutil.rmtree, PIP_TOOLS_CACHE_DIR, ignore_errors=True)

    changes = {}
    failures = {}
    for fpath in options.files:
        if not fpath.endswith('.in'):
            continue
        compile_requirement_file(fpath, options, unknown_args, failures, changes)

    if failures:
        for fpath, stds in failures.items():
            print('Failed to process {}'.format(fpath))
            if stds['exc']:
                print('Exception:')
                print(stds['exc'])
            if stds['stdout']:
                print('STDOUT:')
                print(stds['stdout'])
            if stds['stderr']:
                print('STDERR:')
                print(stds['stderr'])
        sys.exit(1)
    else:
        if changes:
            for fpath, stds in failures.items():
                print('{} contents changed...'.format(fpath))
        sys.exit(0)


if __name__ == '__main__':
    main()
